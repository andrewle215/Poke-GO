<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Plant Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- A-Frame core -->
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <!-- AR.js location-only (optional if you want markerless AR) -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/three.js/build/ar-threex-location-only.js"></script>
  <!-- GPS plugins for A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-gps-camera@1.10.4/dist/aframe-gps-camera.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-gps-projected-camera@1.10.4/dist/aframe-gps-projected-camera.min.js"></script>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; width:100%; height:100%; }
    a-scene { position:fixed; top:0; left:0; width:100%; height:100%; }
    #plant-info {
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.6); color:#fff; padding:0.5em 1em;
      border-radius:4px; font-family:sans-serif; display:none; z-index:10;
    }
  </style>
</head>
<body>
  <a-scene
    vr-mode-ui="enabled:false"
    embedded
    renderer="alpha:true;antialias:true">
    
    <!-- this camera now has the GPS component that fires updates -->
    <a-camera gps-projected-camera="gpsMinDistance:3;rotate:true"></a-camera>
  </a-scene>

  <div id="plant-info"></div>

  <!-- inline your debug & marker code here -->
  <script>
    window.addEventListener("load", () => {
      // â€”â€” Color-by-species palette â€”â€” 
      const speciesColorMap = {};
      function getColorForSpecies(sp) {
        if (!speciesColorMap[sp]) {
          speciesColorMap[sp] = `hsl(${Math.floor(Math.random()*360)},70%,60%)`;
        }
        return speciesColorMap[sp];
      }

      // â€”â€” Grab scene, camera, UI â€”â€” 
      const scene = document.querySelector("a-scene");
      const camEl = document.querySelector("[gps-projected-camera]");
      const info = document.getElementById("plant-info");
      if (!camEl) {
        console.error("ðŸ”´ No <a-camera gps-projected-camera> found!");
        return;
      }

      let userMarker = null;
      const plantDots = {};
      let lastUpdate = 0;
      const UPDATE_INTERVAL = 10_000;
      let first = false;

      // â€”â€” Listen for GPS updates â€”â€” 
      camEl.addEventListener("gps-camera-update-position", e => {
        const { latitude, longitude } = e.detail.position;
        console.log("ðŸŒ GPS:", latitude, longitude);

        // your â€œyou are hereâ€ box
        if (!userMarker) {
          userMarker = document.createElement("a-box");
          userMarker.setAttribute("scale","1 1 1");
          userMarker.setAttribute("material","color:red");
          scene.appendChild(userMarker);
        }
        userMarker.setAttribute(
          "gps-projected-entity-place",
          `latitude:${latitude};longitude:${longitude}`
        );

        const now = Date.now();
        if (!first || now - lastUpdate > UPDATE_INTERVAL) {
          first = true; lastUpdate = now;
          loadAndPlacePlants(latitude, longitude);
        }
      });

      // â€”â€” Fetch + place plants â€”â€” 
      function loadAndPlacePlants(uLat, uLon) {
        fetch("./ABG.csv")
          .then(r => {
            console.log("ðŸ¥£ fetch status:", r.status);
            return r.text();
          })
          .then(txt => {
            const all = parseCSV(txt);
            console.log("ðŸ“‹ parsed:", all.length);
            const nearby = all
              .map(p => ({
                ...p,
                dist: haversine(uLat,uLon,p.lat,p.lon)
              }))
              .filter(p => p.dist <= 1000)  // TEMP wide radius
              .sort((a,b)=>a.dist-b.dist)
              .slice(0,10);
            console.log("âž¡ï¸ showing:", nearby);

            // add/update dots
            nearby.forEach(p => {
              const c = getColorForSpecies(p.species||p.genus);
              if (plantDots[p.s_id]) {
                plantDots[p.s_id].setAttribute(
                  "gps-projected-entity-place",
                  `latitude:${p.lat};longitude:${p.lon}`
                );
              } else {
                const dot = document.createElement("a-sphere");
                dot.setAttribute("radius","1");
                dot.setAttribute("material",`color:${c};opacity:0.8`);
                dot.setAttribute("look-at","[gps-projected-camera]");
                dot.classList.add("clickable");
                dot.setAttribute(
                  "gps-projected-entity-place",
                  `latitude:${p.lat};longitude:${p.lon}`
                );
                dot.addEventListener("click",()=>{
                  info.style.display="block";
                  info.innerHTML=`
                    <strong>${p.cname2?p.cname2+", ":""}${p.cname1}</strong><br>
                    Genus: ${p.genus}<br>Species: ${p.species}
                  `;
                  setTimeout(()=>info.style.display="none",3000);
                });
                scene.appendChild(dot);
                plantDots[p.s_id]=dot;
              }
            });

            // cleanup
            Object.keys(plantDots).forEach(id=>{
              if (!nearby.find(x=>x.s_id===id)) {
                scene.removeChild(plantDots[id]);
                delete plantDots[id];
              }
            });
          })
          .catch(err=>console.error("âŒ CSV error:",err));
      }

      // â€”â€” CSV â†’ JS objects â€”â€” 
      function parseCSV(txt) {
        return txt.split("\n").slice(1).map(r=>{
          const c = r.split(",");
          while(c.length<11) c.push("");
          return {
            s_id:c[0].trim(),
            cname1:c[1].trim()||"Unknown",
            cname2:c[2].trim()||"",
            genus:c[4].trim()||"Unknown",
            species:c[5].trim()||"",
            lon:parseFloat(c[7])||0,
            lat:parseFloat(c[8])||0
          };
        }).filter(p=>p.s_id&&p.lat&&p.lon);
      }

      // â€”â€” Haversine distance â€”â€” 
      function haversine(lat1,lon1,lat2,lon2) {
        const R = 6371e3, toRad=Math.PI/180;
        const Ï†1=lat1*toRad, Ï†2=lat2*toRad;
        const dÏ†=(lat2-lat1)*toRad, dÎ»=(lon2-lon1)*toRad;
        const a=Math.sin(dÏ†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(dÎ»/2)**2;
        return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
      }
    });
  </script>
</body>
</html>
