<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Plant Map</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- 1) Leaflet CSS must come first -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha512-..."
        crossorigin="" />

    <!-- 2) (Optional) MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <style>
        /* make sure the map container actually fills the screen */
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .plant-popup {
            font-size: 0.9em;
            line-height: 1.2;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- 3) Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha512-..." crossorigin=""></script>
    <!-- 4) (Optional) MarkerCluster plugin -->
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <script>
        // initialize the map
        const map = L.map("map").fitWorld();

        // add OpenStreetMap tiles
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "&copy; OpenStreetMap contributors",
        }).addTo(map);

        // optional clustering for dense areas
        const clusterGroup = L.markerClusterGroup();
        map.addLayer(clusterGroup);

        // watch the user's location, recenter when found
        map.locate({ watch: true, setView: true, maxZoom: 18 });

        map.on("locationfound", (e) => {
            // properly pull lat/lng and accuracy from the event
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            const accuracy = e.accuracy;

            // draw/update the blue “you are here” dot + accuracy circle
            if (!window._userMarker) {
                window._userMarker = L.marker([lat, lon]).addTo(map);
                window._accuracyCircle = L.circle([lat, lon], { radius: accuracy }).addTo(map);
            } else {
                window._userMarker.setLatLng([lat, lon]);
                window._accuracyCircle.setLatLng([lat, lon]).setRadius(accuracy);
            }

            // throttle plant reloads to once every 5s
            if (!window._lastFetch || Date.now() - window._lastFetch > 5000) {
                window._lastFetch = Date.now();
                loadAndDisplayPlants(lat, lon);
            }
        });

        map.on("locationerror", (err) => {
            alert("Could not get your location: " + err.message);
        });

        function loadAndDisplayPlants(userLat, userLon) {
            fetch("./ABG.csv")
                .then((r) => r.text())
                .then((csv) => {
                    clusterGroup.clearLayers();
                    const plants = parseCSV(csv)
                        .map((p) => ({
                            ...p,
                            dist: getDistance(userLat, userLon, p.lat, p.lon),
                        }))
                        .filter((p) => p.dist <= 100)   // show within 100m
                        .sort((a, b) => a.dist - b.dist);

                    plants.forEach((p) => {
                        const m = L.marker([p.lat, p.lon]);
                        m.bindPopup(`
              <div class="plant-popup">
                <strong>${p.cname1}${p.cname2 ? ", " + p.cname2 : ""}</strong><br>
                Genus: ${p.genus}<br>
                Species: ${p.species}<br>
                Distance: ${Math.round(p.dist)} m
              </div>
            `);
                        clusterGroup.addLayer(m);
                    });
                })
                .catch(console.error);
        }

        function parseCSV(txt) {
            return txt
                .split("\n")
                .slice(1)
                .map((r) => {
                    const c = r.split(",");
                    while (c.length < 11) c.push("");
                    return {
                        s_id: c[0].trim(),
                        cname1: c[1].trim() || "Unknown",
                        cname2: c[2].trim() || "",
                        genus: c[4].trim() || "Unknown",
                        species: c[5].trim() || "",
                        lon: parseFloat(c[7]) || 0,
                        lat: parseFloat(c[8]) || 0,
                        height: parseFloat(c[10]) || 1,
                    };
                })
                .filter((p) => p.s_id && p.lat && p.lon);
        }

        // Haversine formula
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3,
                toRad = Math.PI / 180;
            const φ1 = lat1 * toRad,
                φ2 = lat2 * toRad;
            const dφ = (lat2 - lat1) * toRad,
                dλ = (lon2 - lon1) * toRad;
            const a =
                Math.sin(dφ / 2) ** 2 +
                Math.cos(φ1) * Math.cos(φ2) * Math.sin(dλ / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    </script>
</body>

</html>